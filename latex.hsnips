# todo

## test math mode and text mode
## xhat, xbar, xcal
## autowrap math mode macros in text mode?
## cycle through similar macros

# globals

global
// const math = (context) => {
//   for (scope of context.scopes) {
//     if (scope.startsWith('meta.math')) {
//       return true;
//     } else if (scope.startsWith('meta.text')) {
//       return false;
//     }
//   }
//   return false;
// };
const math = (context) => true;

// const text = (context) => !math(context);
const text = (context) => true;

let fsm_mode = false;

let autosubscript_mode = true;

endglobal

# quality of life

## macros

context math(context)
snippet `\\xa ` "alpha" A
\alpha
endsnippet

context math(context)
snippet `\\xA ` "Alpha" A
\Alpha
endsnippet

context math(context)
snippet `\\xb ` "beta" A
\beta
endsnippet

context math(context)
snippet `\\xB ` "Beta" A
\Beta
endsnippet

context math(context)
snippet `\\xg ` "gamma" A
\gamma
endsnippet

context math(context)
snippet `\\xG ` "Gamma" A
\Gamma
endsnippet

context math(context)
snippet `\\xd ` "delta" A
\delta
endsnippet

context math(context)
snippet `\\xD ` "Delta" A
\Delta
endsnippet

context math(context)
snippet `\\xe ` "epsilon" A
\epsilon
endsnippet

context math(context)
snippet `\\xE ` "Epsilon" A
\Epsilon
endsnippet

context math(context)
snippet `\\xve ` "epsilon" A
\varepsilon
endsnippet

context math(context)
snippet `\\xl ` "lambda" A
\lambda
endsnippet

context math(context)
snippet `\\xL ` "Lambda" A
\Lambda
endsnippet

context math(context)
snippet `\\xm ` "mu" A
\mu
endsnippet

context math(context)
snippet `\\xM ` "Mu" A
\Mu
endsnippet

context math(context)
snippet `\\xp ` "pi" A
\pi
endsnippet

context math(context)
snippet `\\xP ` "Pi" A
\Pi
endsnippet

context math(context)
snippet `\\xt ` "tau" A
\tau
endsnippet

context math(context)
snippet `\\xT ` "Tau" A
\Tau
endsnippet

context math(context)
snippet `\\xf ` "phi" A
\phi
endsnippet

context math(context)
snippet `\\xF ` "Phi" A
\Phi
endsnippet

context math(context)
snippet `\\xr ` "rho" A
\rho
endsnippet

context math(context)
snippet `\\xR ` "Rho" A
\Rho
endsnippet

context math(context)
snippet `\\xs ` "sigma" A
\sigma
endsnippet

context math(context)
snippet `\\xS ` "Sigma" A
\Sigma
endsnippet

context math(context)
snippet `\\xh ` "theta" A
\theta
endsnippet

context math(context)
snippet `\\xH ` "Theta" A
\Theta
endsnippet

context math(context)
snippet `\\xo ` "omega" A
\omega
endsnippet

context math(context)
snippet `\\xO ` "Omega" A
\Omega
endsnippet

context math(context)
snippet `\\then ` "then" A
\Rightarrow
endsnippet

context math(context)
snippet `\\R ` "reals" A
\mathbb R
endsnippet

context math(context)
snippet `\\Q ` "rationals" A
\mathbb Q
endsnippet

context math(context)
snippet `\\Z ` "integers" A
\mathbb Z
endsnippet

context math(context)
snippet `\\N ` "naturals" A
\mathbb N
endsnippet

context math(context)
snippet `\\A ` "for all" A
\forall \,
endsnippet

context math(context)
snippet `\\E ` "there exists" A
\exists \,
endsnippet

context math(context)
snippet `\\nullset ` "empty set" A
\varnothing
endsnippet

snippet `\\it ` "italics text" A
\textit{$1}$0
endsnippet

snippet `\\ve ` "inline verbatim" A
\verb~$1~$0
endsnippet

snippet `\\bf ` "bold font" A
{\boldmath \bfseries $1}$0
endsnippet

context math(context)
snippet `\\abs ` "absolute value" A
\left | $1 \right |$0
endsnippet

context math(context)
snippet `\\paren ` "parentheses" A
\left ( $1 \right )$0
endsnippet

context math(context)
snippet `\\setof ` "set of" A
\left \\{ $1 \right \\}$0
endsnippet

context math(context)
snippet `\\set ` "set generator" A
\left \\{ $1 : $2 \right \\}$0
endsnippet

context math(context)
snippet `\\vecof ` "vector of" A
\begin{bmatrix} $1 \end{bmatrix}$0
endsnippet

context math(context)
snippet `\\op ` "operator name" A
\operatorname{$1}$0 
endsnippet

context math(context)
snippet `\\f ` "fraction" A
\frac{$1}{$2}$0
endsnippet

context math(context)
snippet `\\dtof([^/]*)/([^/]*)\\dtof ` "divide to fraction" A
``rv = `\\frac\{${m[1].trim()}\}\{${m[2].trim()}\}```
endsnippet

## efficiency

snippet lkj "slash" iA
\
endsnippet

snippet nl "newline" A 
\\\\
endsnippet

snippet ddd "dot dot dot" iA
\dots
endsnippet

snippet begin "begin/end block" i
\begin{$1}
  $0
\end{$1}
endsnippet

context text(context)
snippet imm "inline math" iA
$$1$
endsnippet

context text(context)
snippet bm "block math" b
\[
  $0
\]
endsnippet

context text(context)
snippet bn "numbered block math" b
\begin{equation}
  $0
\end{equation}
endsnippet

context text(context)
snippet bmm "multiline block math" b
\begin{align*}
  $0
\end{align*}
endsnippet

context text(context)
snippet `(^|[^a-zA-Z])im([a-zA-Z])([^a-zA-Z])` "single character inline math" A
``rv = `${m[1]}\$${m[2]}\$${m[3]}```
endsnippet

snippet `\\autosubs ` "autosubscript on" A
``autosubscript_mode = true``
endsnippet

snippet `\\noautosubs ` "autosubscript off" A
``autosubscript_mode = false``
endsnippet

context math(context) && autosubscript_mode
snippet `([a-zA-Z])([0-9])` "autosubscript" A
``rv = `${m[1]}_${m[2]}```
endsnippet

context math(context)
snippet `([a-zA-Z])_([0-9][0-9])` "extended autosubscript" A
``rv = `${m[1]}_\{${m[2]}${snip.tabstop(1)}\}${snip.tabstop(0)}```
endsnippet

context math(context)
snippet sb "subscript" iA
_
endsnippet

context math(context)
snippet Sb "subscript group" iA
_{$1}$0
endsnippet

context math(context)
snippet td "superscript" iA
^
endsnippet

context math(context)
snippet Td "superscript group" iA
^{$1}$0
endsnippet

context math(context)
snippet `(.) pl ([a-zA-Z0-9])` "plus" iA
``rv = `${m[1]} + ${m[2]}```
endsnippet

context math(context)
snippet `(.) ms ([a-zA-Z0-9])` "minus" iA
``rv = `${m[1]} - ${m[2]}```
endsnippet

context math(context)
snippet ` gt ` "greater than" A
 > 
endsnippet

context math(context)
snippet ` lt ` "less than" A
 < 
endsnippet

context math(context)
snippet `(.) tm ([a-zA-Z0-9])` "times" iA
``rv = `${m[1]} \\cdot ${m[2]}```
endsnippet

context math(context)
snippet `([^a-zA-Z])plus` "plus" iA
``rv = `${m[1]}+```
endsnippet

context math(context)
snippet `([^a-zA-Z])minus` "minus" iA
``rv = `${m[1]}-```
endsnippet

context math(context)
snippet apes "aligned equals" A
&=
endsnippet

context math(context)
snippet dfes "define" A
:=
endsnippet

# layouts

snippet `\\centered ` "centered" A
\begin{center}
  $1
\end{center}$0
endsnippet

snippet `\\2col ` "2 columns" A
\begin{minipage}{0.45 \textwidth}
  \begin{center}
    $1
  \end{center}
\end{minipage}%
\hspace*{\fill}%
\begin{minipage}{0.45 \textwidth}
  \begin{center}
    $2
  \end{center}
\end{minipage}$0
endsnippet

# graphs

snippet `\\graph ` "y = f(x) graph" A
\begin{tikzpicture}[scale = 0.75]
  \begin{axis}[
    xmin = $1, xmax = $2, 
    ymin = $3, ymax = $4, 
    axis x line = center, 
    axis y line = center, 
    axis equal]
    \addplot[no marks, very thick, domain = $5 : $6]{$7};
  \end{axis}
\end{tikzpicture}$0
endsnippet

# finite state machines

snippet `\\fsm ` "fsm on" iA
``fsm_mode = true;``
endsnippet

snippet `\\nofsm ` "fsm off" iA
``fsm_mode = false;``
endsnippet

context fsm_mode
snippet `\\dfsm ` "draw fsm" bA
\begin{tikzpicture}[> = stealth, node distance = 3em]
  $1
  \draw[->]
  $0
  ;
\end{tikzpicture}
endsnippet

context fsm_mode
snippet ` n ` "declare node" A
 \node[$3state, minimum size = 2em] ($1) {$2};
endsnippet

context fsm_mode
snippet ` an ` "declare anonymous node" A
 \node[$2state, minimum size = 2em] ($1) {};
endsnippet

context fsm_mode
snippet `node\[in ` "initial state" A
node[$0initial, initial text=, 
endsnippet

context fsm_mode
snippet `node\[ac ` "accepting state" A
node[$0accepting, 
endsnippet

context fsm_mode
snippet `node\[([ablr])([lr]?) ` "node position" A
``
let position = '';
if (m[1] === 'a') {
  if (m[2] === '') {
    position = 'above';
  } else if (m[2] === 'l') {
    position = 'above left';
  } else if (m[2] === 'r') {
    position = 'above right';
  }
} else if (m[1] === 'b') {
  if (m[2] === '') {
    position = 'below';
  } else if (m[2] === 'l') {
    position = 'below left';
  } else if (m[2] === 'r') {
    position = 'below right';
  }
} else if (m[1] === 'l') {
  position = 'left';
} else if (m[1] === 'r') {
  position = 'right';
}
if (position === '') {
  rv = 'node[';
} else {
  rv = `node[${snip.tabstop(0)}${position} = of ${snip.tabstop(1)}, `;
}
``
endsnippet

context fsm_mode
snippet ` e ` "declare edge" A
 ($1) edge[$0] node{$3} ($2)
endsnippet

context fsm_mode
snippet `verb~(.), ` "parallel transitions" A
``rv = `verb~${m[1]}~,\\verb~${snip.tabstop(0)}```
endsnippet

context fsm_mode
snippet `edge\[([ablr])([ablr]?) ` "edge shape & label position" A
``
let position = '';
if (m[1] === 'a') {
  if (m[2] === '') {
    position = 'above';
  } else if (m[2] === 'l') {
    position = 'above left';
  } else if (m[2] === 'r') {
    position = 'above right';
  }
} else if (m[1] === 'b') {
  if (m[2] === '') {
    position = 'below';
  } else if (m[2] === 'l') {
    position = 'below left';
  } else if (m[2] === 'r') {
    position = 'below right';
  }
} else if (m[1] === 'l') {
  if (m[2] === '') {
    position = 'left';
  } else if (m[2] === 'a') {
    position = 'loop above';
  } else if (m[2] === 'b') {
    position = 'loop below';
  } else if (m[2] === 'l') {
    position = 'loop left';
  } else if (m[2] === 'r') {
    position = 'loop right';
  }
} else if (m[1] === 'r') {
  position = 'right';
}
if (position === '') {
  rv = 'edge[';
} else {
  rv = `edge[${snip.tabstop(0)}${position}`;
}
``
endsnippet

context fsm_mode
snippet `edge\[bd ` "edge bend" A
edge[$0bend right, 
endsnippet

# templates

snippet homework "homework template" b
\documentclass{homework}

\class{$1}
\num{$2}
\name{$3}
\solutionColor{red}

\begin{document}

$0

\end{document}
endsnippet

snippet notes "notes template" b
\documentclass{homework}

\class{$1}

\begin{document}

$0

\end{document}
endsnippet

snippet tmpl "generic template (obsolete)" b
\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin = 1in]{geometry}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\iffalse \usepackage{palatino} \fi
\usepackage{tikz-cd}
\usetikzlibrary{arrows}
\usepackage{pgfplots}
\pgfplotsset{compat = 1.17}
\usepackage{multicol}
\usepackage[mathscr]{euscript}
\let \euscr \mathscr
\let \mathscr \relax
\usepackage[scr]{rsfso}
\usepackage{siunitx}
\sisetup{inter-unit-product = \cdot, per-mode = symbol}
\usepackage{graphicx}
\graphicspath{{./img/}}
\usepackage{esint}
\usepackage{hyperref} % \eqref{<label>}
\usepackage{enumitem} % [noitemsep, topsep = <sep>] for enumerate & itemize
\usepackage{mathtools} % \xRightarrow[math below]{math above}
\usepackage{microtype}
\usepackage{soul} % \hl{<text>}

\newcommand{\R}{\mathbb R}
\newcommand{\F}{\mathbb F}
\newcommand{\C}{\mathbb C}
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Q}{\mathbb Q}
\newcommand{\union}{\cup}
\newcommand{\intersection}{\cap}
\newcommand{\nullset}{\varnothing}
\renewcommand{\vec}{\mathbf}
\newcommand{\vvec}{\boldsymbol}
\newcommand{\norm}[1]{\left \lVert #1 \right \rVert}
\newcommand{\set}[2]{\left \{ #1: #2 \right \\}}
\newcommand{\setgen}[2]{\left \{ \, #1 ~ : ~ #2 \, \right \\}}
\newcommand{\setof}[1]{\left \{ #1 \right \\}}
\newcommand{\ip}[2]{\left \langle #1, #2 \right \rangle} % inner product
\newcommand{\A}{\forall\,}
\newcommand{\E}{\exists\,}
\newcommand{\nE}{\nexists\,}
\newcommand{\ve}{\varepsilon}
\newcommand{\abs}[1]{\left | #1 \right |}
\newcommand{\paren}[1]{\left ( #1 \right )}
\DeclareMathOperator{\proj}{proj}
\newcommand{\powerset}{\mathscr P}
\DeclareSIUnit \atmosphere {atm}
\newcommand{\Part}[1]{\operatorname{Part} \paren{#1}}
\newcommand{\vol}[1]{\operatorname{vol} \paren{#1}}
\newcommand{\vecof}[1]{\left \langle #1 \right \rangle}
\newcommand{\Div}{\operatorname{div}}
\newcommand{\curl}{\operatorname{curl}}
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pdx}[1]{\frac{\partial #1}{\partial x}}
\newcommand{\pdy}[1]{\frac{\partial #1}{\partial y}}
\newcommand{\pdz}[1]{\frac{\partial #1}{\partial z}}
\newcommand{\pdo}[1]{\frac{\partial}{\partial #1}}
\newcommand{\floor}[1]{\left \lfloor #1 \right \rfloor}
\newcommand{\ceil}[1]{\left \lceil #1 \right \rceil}
\newcommand{\inO}[1]{\tikz[baseline=(char.base)]{\node[shape = circle, draw, inner sep = 2pt] (char) {#1};}}
\newcommand{\tab}{\phantom{ } \phantom{ } }
\newcommand{\ls}{<\phantom{}< } % left shift
\newcommand{\rs}{>\phantom{}> } % right shift
\newenvironment{fbmatrix}[1]{\left [ \begin{array}{#1}}{\end{array} \right ]}
\newcommand{\im}{\operatorname{im}}
\newcommand{\centergraphics}[2][]{\begin{center}\includegraphics[#1]{#2}\end{center}}
\newcommand{\vspan}{\operatorname{span}}
\newcommand{\spanof}[1]{\vspan\setof{#1}}
\newcommand{\bvecof}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\nullity}{\operatorname{nullity}}
\newcommand{\tr}{\operatorname{tr}} % trace function
\mathchardef \hyphen = "2D % hyphens in math mode
\newtheorem{thm}{Theorem} % theorem environment
\newtheorem{defn}{Definition} % definition environment
\newtheorem{lem}{Lemma} % lemma environment
\newcommand{\noparskip}{\vspace{-\parskip}}
\makeatletter
\def\namedlabel#1#2{\begingroup
  #2%
  \def\@currentlabel{#2}%
  \phantomsection\label{#1}\endgroup
}
\makeatother % \namedlabel{<label>}{<text>} in list item for \ref{<label>}
\newcommand{\toc}{\microtypesetup{protrusion = false} \tableofcontents \microtypesetup{protrusion = true}}
\newcommand{\Dom}{\operatorname{Dom}}
\newcommand{\Ran}{\operatorname{Ran}}

\newenvironment{lenumerate}{\begin{enumerate}[leftmargin = 0pt]\setlength{\parskip}{0.8em}}{\end{enumerate}}
\newenvironment{answer}{\spc \color{red} \textbf{\textit{Solution.}} \color{black}}{\spc}
\newcommand{\spc}{\vspace{0.25cm}}

\linespread{1.2}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}

\begin{document}

$0

\end{document}
endsnippet

# personal snippets

snippet {me "me" i
{Lucas Jeong
endsnippet

snippet {m131bh "math131bh" i
{MATH 131BH (Real Analysis)
endsnippet

snippet {cs181 "cs181" i
{COM SCI 181
endsnippet

snippet {ece102 "ece102" i
{ECE 102 (Systems and Signals)
endsnippet