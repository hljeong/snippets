# todo

## autowrap math mode macros in text mode

# globals

global
const math = (context) => {
  for (scope of context.scopes) {
    if (scope.startsWith('meta.math')) {
      return true;
    } else if (scope.startsWith('meta.text')) {
      return false;
    }
  }
  return false;
};

const text = (context) => !math(context);

let fsm_mode = false;

const fsm = (context) => fsm_mode;
endglobal

# quality of life

## macros

### without tabstops

context math(context)
snippet `([^a-zA-Z])\xa` "alpha" A
``rv = `${m[1]}\\alpha```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xb` "beta" A
``rv = `${m[1]}\\beta```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xg` "gamma" A
``rv = `${m[1]}\\gamma```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xd` "delta" A
``rv = `${m[1]}\\delta```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xe` "epsilon" A
``rv = `${m[1]}\\epsilon```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xve` "epsilon" A
``rv = `${m[1]}\\varepsilon```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xl` "lambda" A
``rv = `${m[1]}\\lambda```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xm` "mu" A
``rv = `${m[1]}\\mu```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xp` "pi" A
``rv = `${m[1]}\\pi```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xt` "tau" A
``rv = `${m[1]}\\tau```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xf` "phi" A
``rv = `${m[1]}\\phi```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xr` "rho" A
``rv = `${m[1]}\\rho```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xs` "sigma" A
``rv = `${m[1]}\\sigma```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xh` "theta" A
``rv = `${m[1]}\\theta```
endsnippet

context math(context)
snippet `([^a-zA-Z])\xo` "omega" A
``rv = `${m[1]}\\omega```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\R` "reals" A
``rv = `${m[1]}\\mathbb R```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\Q` "rationals" A
``rv = `${m[1]}\\mathbb Q```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\N` "naturals" A
``rv = `${m[1]}\\mathbb N```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\A` "for all" A
``rv = `${m[1]}\\forall \\,```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\E` "there exists" A
``rv = `${m[1]}\\exists \\,```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\nullset` "empty set" A
``rv = `${m[1]}\\varnothing```
endsnippet

### with tabstops

snippet `([^a-zA-Z])\\it ` "italics text" A
``rv = `${m[1]}\\textit\{${snip.tabstop(1)}\}${snip.tabstop(0)}```
endsnippet

snippet `([^a-zA-Z])\\ve ` "inline verbatim" A
``rv = `${m[1]}\\verb~${snip.tabstop(1)}~${snip.tabstop(0)}```
endsnippet

snippet `([^a-zA-Z])\\bf ` "bold font" A
``rv = `${m[1]}\{\\boldmath \\bfseries ${snip.tabstop(1)}\}${snip.tabstop(0)}```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\abs ` "absolute value" A
``rv = `${m[1]}\\left | ${snip.tabstop(1)} \\right |${snip.tabstop(0)}```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\paren ` "parentheses" A
``rv = `${m[1]}\\left \\\( ${snip.tabstop(1)} \\right \\\\\)${snip.tabstop(0)}```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\setof ` "set of" A
``rv = `${m[1]}\\left \\\{ ${snip.tabstop(1)} \\right \\\\\}${snip.tabstop(0)}```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\set ` "set generator" A
``rv = `${m[1]}\\left \\\{ ${snip.tabstop(1)} : ${snip.tabstop(2)} \\right \\\\\}${snip.tabstop(0)}```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\op ` "operator name" A
``rv = `${m[1]}\\operatorname\{${snip.tabstop(1)}\}${snip.tabstop(0)}```
endsnippet

context math(context)
snippet `([^a-zA-Z])\\f ` "fraction" A
``rv = `${m[1]}\\frac\{${snip.tabstop(1)}\}\{${snip.tabstop(2)}\}${snip.tabstop(0)}```
endsnippet

## efficiency

snippet lkj "slash" iA
\
endsnippet

snippet nl "newline" A 
\\\\
endsnippet

snippet ddd "dot dot dot" iA
\dots
endsnippet

snippet begin "begin/end block" i
\begin{$1}
  $0
\end{$1}
endsnippet

context text(context)
snippet imm "inline math" iA
$$1$
endsnippet

context text(context)
snippet bm "block math" b
\[
  $0
\]
endsnippet

context text(context)
snippet bn "numbered block math" b
\begin{equation}
  $0
\end{equation}
endsnippet

context text(context)
snippet bmm "multiline block math" b
\begin{align*}
  $0
\end{align*}
endsnippet

#### experimental
context text(context)
snippet `(^|[^a-zA-Z])im([a-zA-Z])([^a-zA-Z])` "single character inline math" A
``rv = `${m[1]}\$${m[2]}\$${m[3]}```
endsnippet

context math(context)
snippet sb "subscript" iA
_
endsnippet

context math(context)
snippet Sb "subscript group" iA
_{$1}$0
endsnippet

context math(context)
snippet td "superscript" iA
^
endsnippet

context math(context)
snippet Td "superscript group" iA
^{$1}$0
endsnippet

context math(context)
snippet `([^a-zA-Z])plus` "plus" iA
``rv = `${m[1]}+```
endsnippet

context math(context)
snippet `([^a-zA-Z])minus` "minus" iA
``rv = `${m[1]}-```
endsnippet

context math(context)
snippet `([^a-zA-Z])gt` "greater than" A
``rv = `${m[1]}>```
endsnippet

context math(context)
snippet `([^a-zA-Z])lt` "less than" A
``rv = `${m[1]}<```
endsnippet

context math(context)
snippet apes "aligned equals" A
&=
endsnippet

context math(context)
snippet dfes "define" A
:=
endsnippet

# layouts

snippet `\\centered ` "centered" A
\begin{center}
  $1
\end{center}$0
endsnippet

snippet `\\2col ` "2 columns" A
\begin{minipage}{0.5 \textwidth}
  \begin{center}
    $1
  \end{center}
\end{minipage}%
\begin{minipage}{0.5 \textwidth}
  \begin{center}
    $2
  \end{center}
\end{minipage}$0
endsnippet

# finite state machines

snippet \fsm "enable fsm snippets" iA
``fsm_mode = true;``
endsnippet

snippet \nofsm "disable fsm snippets" iA
``fsm_mode = false;``
endsnippet

context fsm(context)
snippet fsm "draw fsm" bA
\begin{tikzpicture}[> = stealth, node distance = 5em]
  $1
  \draw[->]
  $0
  ;
\end{tikzpicture}
endsnippet

context fsm(context)
snippet ` n ` "declare node" A
 \node[$2state, minimum size = 2em] (q$1) {\$q_$1\$};
endsnippet

context fsm(context)
snippet ` an ` "declare anonymous node" A
 \node[$2state, minimum size = 2em] (q$1) {};
endsnippet

context fsm(context)
snippet `node\[in ` "initial state" A
node[$0initial, initial text=, 
endsnippet

context fsm(context)
snippet `node\[ac ` "accepting state" A
node[$0accepting, 
endsnippet

context fsm(context)
snippet `node\[([ablr])([lr]?) ` "node position" A
``
let position = '';
if (m[1] === 'a') {
  if (m[2] === '') {
    position = 'above';
  } else if (m[2] === 'l') {
    position = 'above left';
  } else if (m[2] === 'r') {
    position = 'above right';
  }
} else if (m[1] === 'b') {
  if (m[2] === '') {
    position = 'below';
  } else if (m[2] === 'l') {
    position = 'below left';
  } else if (m[2] === 'r') {
    position = 'below right';
  }
} else if (m[1] === 'l') {
  position = 'left';
} else if (m[1] === 'r') {
  position = 'right';
}
if (position === '') {
  rv = 'node[';
} else {
  rv = `node[${snip.tabstop(0)}${position} of = q${snip.tabstop(1)}, `;
}
``
endsnippet

context fsm(context)
snippet ` e ` "declare edge" A
 (q$1) edge[$0] node{\verb~$3~} (q$2)
endsnippet

context fsm(context)
snippet `verb~(.), ` "parallel transitions" A
``rv = `verb~${m[1]}~,\\verb~${snip.tabstop(0)}```
endsnippet

context fsm(context)
snippet `edge\[([ablr])([ablr]?) ` "edge shape & label position" A
``
let position = '';
if (m[1] === 'a') {
  if (m[2] === '') {
    position = 'above';
  } else if (m[2] === 'l') {
    position = 'above left';
  } else if (m[2] === 'r') {
    position = 'above right';
  }
} else if (m[1] === 'b') {
  if (m[2] === '') {
    position = 'below';
  } else if (m[2] === 'l') {
    position = 'below left';
  } else if (m[2] === 'r') {
    position = 'below right';
  }
} else if (m[1] === 'l') {
  if (m[2] === '') {
    position = 'left';
  } else if (m[2] === 'a') {
    position = 'loop above';
  } else if (m[2] === 'b') {
    position = 'loop below';
  } else if (m[2] === 'l') {
    position = 'loop left';
  } else if (m[2] === 'r') {
    position = 'loop right';
  }
} else if (m[1] === 'r') {
  position = 'right';
}
if (position === '') {
  rv = 'edge[';
} else {
  rv = `edge[${snip.tabstop(0)}${position}`;
}
``
endsnippet

context fsm(context)
snippet `edge\[bd ` "edge bend" A
edge[$0bend right, 
endsnippet

# templates

snippet homework "homework template" b
\documentclass{homework}

\class{$1}
\num{$2}
\name{$3}

\begin{document}

$0

\end{document}
endsnippet

snippet notes "notes template" b
\documentclass{homework}

\class{$1}

\begin{document}

$0

\end{document}
endsnippet

snippet tmpl "generic template (obsolete)" b
\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin = 1in]{geometry}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\iffalse \usepackage{palatino} \fi
\usepackage{tikz-cd}
\usetikzlibrary{arrows}
\usepackage{pgfplots}
\pgfplotsset{compat = 1.17}
\usepackage{multicol}
\usepackage[mathscr]{euscript}
\let \euscr \mathscr
\let \mathscr \relax
\usepackage[scr]{rsfso}
\usepackage{siunitx}
\sisetup{inter-unit-product = \cdot, per-mode = symbol}
\usepackage{graphicx}
\graphicspath{{./img/}}
\usepackage{esint}
\usepackage{hyperref} % \eqref{<label>}
\usepackage{enumitem} % [noitemsep, topsep = <sep>] for enumerate & itemize
\usepackage{mathtools} % \xRightarrow[math below]{math above}
\usepackage{microtype}
\usepackage{soul} % \hl{<text>}

\newcommand{\R}{\mathbb R}
\newcommand{\F}{\mathbb F}
\newcommand{\C}{\mathbb C}
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Q}{\mathbb Q}
\newcommand{\union}{\cup}
\newcommand{\intersection}{\cap}
\newcommand{\nullset}{\varnothing}
\renewcommand{\vec}{\mathbf}
\newcommand{\vvec}{\boldsymbol}
\newcommand{\norm}[1]{\left \lVert #1 \right \rVert}
\newcommand{\set}[2]{\left \{ #1: #2 \right \\}}
\newcommand{\setgen}[2]{\left \{ \, #1 ~ : ~ #2 \, \right \\}}
\newcommand{\setof}[1]{\left \{ #1 \right \\}}
\newcommand{\ip}[2]{\left \langle #1, #2 \right \rangle} % inner product
\newcommand{\A}{\forall\,}
\newcommand{\E}{\exists\,}
\newcommand{\nE}{\nexists\,}
\newcommand{\ve}{\varepsilon}
\newcommand{\abs}[1]{\left | #1 \right |}
\newcommand{\paren}[1]{\left ( #1 \right )}
\DeclareMathOperator{\proj}{proj}
\newcommand{\powerset}{\mathscr P}
\DeclareSIUnit \atmosphere {atm}
\newcommand{\Part}[1]{\operatorname{Part} \paren{#1}}
\newcommand{\vol}[1]{\operatorname{vol} \paren{#1}}
\newcommand{\vecof}[1]{\left \langle #1 \right \rangle}
\newcommand{\Div}{\operatorname{div}}
\newcommand{\curl}{\operatorname{curl}}
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pdx}[1]{\frac{\partial #1}{\partial x}}
\newcommand{\pdy}[1]{\frac{\partial #1}{\partial y}}
\newcommand{\pdz}[1]{\frac{\partial #1}{\partial z}}
\newcommand{\pdo}[1]{\frac{\partial}{\partial #1}}
\newcommand{\floor}[1]{\left \lfloor #1 \right \rfloor}
\newcommand{\ceil}[1]{\left \lceil #1 \right \rceil}
\newcommand{\inO}[1]{\tikz[baseline=(char.base)]{\node[shape = circle, draw, inner sep = 2pt] (char) {#1};}}
\newcommand{\tab}{\phantom{ } \phantom{ } }
\newcommand{\ls}{<\phantom{}< } % left shift
\newcommand{\rs}{>\phantom{}> } % right shift
\newenvironment{fbmatrix}[1]{\left [ \begin{array}{#1}}{\end{array} \right ]}
\newcommand{\im}{\operatorname{im}}
\newcommand{\centergraphics}[2][]{\begin{center}\includegraphics[#1]{#2}\end{center}}
\newcommand{\vspan}{\operatorname{span}}
\newcommand{\spanof}[1]{\vspan\setof{#1}}
\newcommand{\bvecof}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\nullity}{\operatorname{nullity}}
\newcommand{\tr}{\operatorname{tr}} % trace function
\mathchardef \hyphen = "2D % hyphens in math mode
\newtheorem{thm}{Theorem} % theorem environment
\newtheorem{defn}{Definition} % definition environment
\newtheorem{lem}{Lemma} % lemma environment
\newcommand{\noparskip}{\vspace{-\parskip}}
\makeatletter
\def\namedlabel#1#2{\begingroup
  #2%
  \def\@currentlabel{#2}%
  \phantomsection\label{#1}\endgroup
}
\makeatother % \namedlabel{<label>}{<text>} in list item for \ref{<label>}
\newcommand{\toc}{\microtypesetup{protrusion = false} \tableofcontents \microtypesetup{protrusion = true}}
\newcommand{\Dom}{\operatorname{Dom}}
\newcommand{\Ran}{\operatorname{Ran}}

\newenvironment{lenumerate}{\begin{enumerate}[leftmargin = 0pt]\setlength{\parskip}{0.8em}}{\end{enumerate}}
\newenvironment{answer}{\spc \color{red} \textbf{\textit{Solution.}} \color{black}}{\spc}
\newcommand{\spc}{\vspace{0.25cm}}

\linespread{1.2}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}

\begin{document}

$0

\end{document}
endsnippet

# personal snippets

snippet `([^a-zA-Z])me` "me" A
``rv = `${m[1]}Lucas Jeong```
endsnippet

snippet `([^a-zA-Z])m131bh` "math131bh" A
``rv = `${m[1]}MATH 131BH (Real Analysis)```
endsnippet

snippet `([^a-zA-Z])cs181` "cs181" A
``rv = `${m[1]}COM SCI 181```
endsnippet